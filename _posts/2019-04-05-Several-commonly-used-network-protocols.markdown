---
layout:     post
title:      "几种常用的网络协议"
subtitle:   " \"Several commonly used network protocols\""
date:       2019-04-05 15:10:00
author:     "吴庆宝"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 基础
    - 网络
---

>  网络协议

协议可简单理解为计算机之间的一种约定，好比人与人之间对话所使用的语言。在国内，不同地区的人讲的方言都不同，如果要沟通，就要约定一种大家都会的语言，例如全国通用的普通话，普通话就相当于协议，沟通相当于通信，说话内容相当于数据信息。协议需要具备通用的特征，但在早期，每家计算机厂商都根据自己的标准来生产网络产品，这使得不同厂商制造的计算机之间难以通信，严重影响了用户的日常使用。为了应对这些问题，ISO（国际标准化组织）制定了一套国际标准OSI（开放式系统互联通信参考模型），将通信系统标准化。所谓标准化是指建立技术标准，企业按照这个标准来制造产品，这大大提升了产品的兼容性、互操作性以及易用性。

## 一、OSI模型

名称 | 层次 | 功能
---|--- |---
物理层  |   1 |实现计算机系统与网络间的物理连接
数据链路层  |   2 |进行数据打包与解包，形成信息帧
网络层  |   3 |提供数据通过的路由
传输层  |   4 |提供传输顺序信息与响应
会话层  |   5 |建立和中止连接
表示层  |   6 |数据转换、确认数据格式
应用层  |   7 |提供用户程序接口
 
## 二、协议层次

网络中常用协议以及层次关系
![](/img/in-post/post-blog/image001.gif)
 

### 1、 进程/应用程的协议

平时最广泛的协议，这一层的每个协议都由客程序和服务程序两部分组成。程序通过服务器与客户机交互来工作。常见协议有：Telnet、FTP、SMTP、HTTP、DNS等。

### 2、 主机—主机层协议

建立并且维护连接，用于保证主机间数据传输的安全性。这一层主要有两个协议：

TCP（Transmission Control Protocol：传输控制协议；面向连接，可靠传输

UDP（User Datagram Protocol）：用户数据报协议；面向无连接，不可靠传输

### 3、 Internet层协议

负责数据的传输，在不同网络和系统间寻找路由，分段和重组数据报文，另外还有设备寻址。些层包括如下协议：

IP（Internet Protocol）:Internet协议，负责TCP/IP主机间提供数据报服务，进行数据封装并产生协议头，TCP与UDP协议的基础。

ICMP（Internet Control Message Protocol）：Internet控制报文协议。ICMP协议其实是IP协议的的附属协议，IP协议用它来与其它主机或路由器交换错误报文和其它的一些网络情况，在ICMP包中携带了控制信息和故障恢复信息。

ARP（Address Resolution Protocol）协议：地址解析协议。

RARP（Reverse Address Resolution Protocol）：逆向地址解析协议。

## OSI 全称（Open System Interconnection）网络的OSI七层结构
###（1）物理层——Physical 
这是整个OSI参考模型的最低层，它的任务就是提供网络的物理连接。所以，物理层是建立在物理介质上（而不是逻辑上的协议和会话），它提供的是机械和电气接口。主要包括电缆、物理端口和附属设备，如双绞线、同轴电缆、接线设备（如网卡等）、RJ－45接口、串口和并口等在网络中都是工作在这个层次的。 
物理层提供的服务包括：物理连接、物理服务数据单元顺序化（接收物理实体收到的比特顺序，与发送物理实体所发送的比特顺序相同）和数据电路标识。

###（2）数据链路层——DataLink 
数据链路层是建立在物理传输能力的基础上，以帧为单位传输数据，它的主要任务就是进行数据封装和数据链接的建立。封装的数据信息中，地址段含有发送节点和接收节点的地址，控制段用来表示数据连接帧的类型，数据段包含实际要传输的数据，差错控制段用来检测传输中帧出现的错误。 
数据链路层可使用的协议有SLIP、PPP、X.25和帧中继等。常见的集线器和低档的交换机网络设备都是工作在这个层次上，Modem之类的拨号设备也是。工作在这个层次上的交换机俗称“第二层交换机”。 
具体讲，数据链路层的功能包括：数据链路连接的建立与释放、构成数据链路数据单元、数据链路连接的分裂、定界与同步、顺序和流量控制和差错的检测和恢复等方面。

###（3）网络层——Network 
网络层属于OSI中的较高层次了，从它的名字可以看出，它解决的是网络与网络之间，即网际的通信问题，而不是同一网段内部的事。网络层的主要功能即是提供路由，即选择到达目标主机的最佳路径，并沿该路径传送数据包。除此之外，网络层还要能够消除网络拥挤，具有流量控制和拥挤控制的能力。网络边界中的路由器就工作在这个层次上，现在较高档的交换机也可直接工作在这个层次上，因此它们也提供了路由功能，俗称“第三层交换机”。 
网络层的功能包括：建立和拆除网络连接、路径选择和中继、网络连接多路复用、分段和组块、服务选择和流量控制。

###（4）传输层——Transport 
传输层解决的是数据在网络之间的传输质量问题，它属于较高层次。传输层用于提高网络层服务质量，提供可靠的端到端的数据传输，如常说的QoS就是这一层的主要服务。这一层主要涉及的是网络传输协议，它提供的是一套网络数据传输标准，如TCP协议。 
传输层的功能包括：映像传输地址到网络地址、多路复用与分割、传输连接的建立与释放、分段与重新组装、组块与分块。 
根据传输层所提供服务的主要性质，传输层服务可分为以下三大类： 
A类：网络连接具有可接受的差错率和可接受的故障通知率（网络连接断开和复位发生的比率），A类服务是可靠的网络服务，一般指虚电路服务。 
C类：网络连接具有不可接受的差错率，C类的服务质量最差，提供数据报服务或无线电分组交换网均属此类。 
B类：网络连接具有可接受的差错率和不可接受的故障通知率，B类服务介于A类与C类之间，在广域网和互联网多是提供B类服务。

网络服务质量的划分是以用户要求为依据的。若用户要求比较高，则一个网络可能归于C型，反之，则一个网络可能归于B型甚至A型。例如，对于某个电子邮件系统来说，每周丢失一个分组的网络也许可算作A型；而同一个网络对银行系统来说则只能算作C型了。

###（5）会话层——Senssion 
会话层利用传输层来提供会话服务，会话可能是一个用户通过网络登录到一个主机，或一个正在建立的用于传输文件的会话。 
会话层的功能主要有：会话连接到传输连接的映射、数据传送、会话连接的恢复和释放、会话管理、令牌管理和活动管理。

###（6）表示层——Presentation 
表示层用于数据管理的表示方式，如用于文本文件的ASCII和EBCDIC，用于表示数字的1S或2S补码表示形式。如果通信双方用不同的数据表示方法，他们就不能互相理解。表示层就是用于屏蔽这种不同之处。 
表示层的功能主要有：数据语法转换、语法表示、表示连接管理、数据加密和数据压缩。

###（7）应用层——Application 
这是OSI参考模型的最高层，它解决的也是最高层次，即程序应用过程中的问题，它直接面对用户的具体应用。应用层包含用户应用程序执行通信任务所需要的协议和功能，如电子邮件和文件传输等，在这一层中TCP/IP协议中的FTP、SMTP、POP等协议得到了充分应用。 
SNMP(Simple Network Management Protocol,简单网络管理协议)的前身是简单网关监控协议(SGMP)，用来对通信线路进行管理。随后，人们对SGMP进行了很大的修改，特别是加入了符合Internet定义的SMI和MIB：体系结构，改进后的协议就是著名的SNMP。SNMP的目标是管理互联网Internet上众多厂家生产的软硬件平台，因此SNMP受Internet标准网络管理框架的影响也很大。现在SNMP已经出到第三个版本的协议，其功能较以前已经大大地加强和改进了。
 
![](/img/in-post/post-blog/networkPotocol.png)

## ip协议(网络层)
ip协议是互联网的基础协议,它是目前最流行的一种网络协议

### 范围
IP的责任就是把数据从源传送到目的地。它不负责保证传送可靠性，流控制，包顺序和其它对于主机到主机协议来说很普通的服务。

### 接口
这个协议由主机到主机协议调用，而此协议负责调用本地网络协议将数据包传送以下一个网关或目的主机。例如TCP可以调用IP协议，在调用时传送目的地址和源地址作为参数，IP形成数据包并调用本地网络（协议）接口传送数据包。

### 操作
IP实现两个基本功能：寻址和分段。

IP可以根据数据包包头中包括的目的地址将数据包传送到目的地址，在此过程中IP负责选择传送的道路，这种选择道路称为路由功能。如果有些网络内只能传送小数据包，IP可以将数据包重新组装并在报头域内注明。

IP模块中包括这些基本功能，这些模块存在于网络中的每台主机和网关上，而且这些模块（特别在网关上）有路由选择和其它服务功能。

对IP来说，数据包之间没有什么联系，对IP不好说什么连接或逻辑链路。

IP使用四个关键技术提供服务：服务类型，生存时间，选项和报头校验码。

服务类型指希望得到的服务质量。服务类型是一个参数集，这些参数是Internet能够提供服务的代表。这种服务类型由网关使用，用于在特定的网络，或是用于下下一个要经过的网络，或是下一个要对这个数据包进行路由的网关上选择实际的传送参数。生存时间是数据包可以生存的时间上限。它由发送者设置，由经过路由的地方处理。

如果未到达时生存时间为零，抛弃此数据包。对于控制函数来说选项是重要的，但对于通常的通信来说它没有存在的必要。选项包括时间戳，安全和特殊路由。报头校验码保证数据的正确传输。如果校验出错，抛弃整个数据包。

### ip地址
把数据从源传送到目的地时,需要有ip地址才能传输,现在ip地址分为ipv4和ipv6 两种地址,现在最常见的就是ipv4地址,例如127.0.0.1(本机地址) 119.75.217.109(百度ip)

ip传输必须要有明确的ip地址,才能进行数据发送

## tcp(传输层)
TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。

在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内 另一个重要的传输协议。

在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。

应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（ MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体 的TCP层。

TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。

TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。

### 三次握手
TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK ，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。 

TCP三次握手的过程如下：

1. 客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。
2. 服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。
3. 客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。

### 连接成功
连接成功之后双方即可互相传输字节流,并随时可关闭连接,传输的数据有以下特性

- 传输的数据被tcp分割成了最适合发送的数据块 传递给ip协议,这个发送数据称为 报文段 或 段

- tcp作为可靠性连接,每次发送数据段,会启动一个定时器,每次接收数据段,会发送一次确认,如果定时器没有及时收到确认,则会重发数据

- TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。

- 两个应用程序通过TCP连接交换8bit字节构成的字节流。TCP不在字节流中插入记录标识符。我们将这称为字节流服务（bytestreamservice）。如果一方的应用程序先传10字节，又传20字节，再传50字节，连接的另一方将无法了解发方每次发送了多少字节。只要自己的接收缓存没有塞满，TCP 接收方将有多少就收多少。一端将字节流放到TCP连接上，同样的字节流将出现在TCP连接的另一端。

### 四次挥手
建立一个连接需要三次握手，而终止一个连接要经过四次挥手，这是由TCP的半关闭（half-close）造成的。具体过程如下所示。

1. 某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。

2. 接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。

3. 注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。

4. 一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。

5. 接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。 既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。

>“通常”是指，某些情况下，步骤1的FIN随数据一起发送，另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。 在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的，这称为“半关闭”（half-close）。 当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN。 无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。

### php中的tcp
php可通过socket函数,swoole扩展,stream流函数进行创建tcp协议的socket,绑定网卡端口,进行tcp服务端/客户端操作 

在php中,我们并不需要了解tcp的握手/挥手,我们只需要知道ip:port能连接/创建 一个tcp服务端/客户端就行了

使用php的socket,我们可以直接发送字符串,接收的也是字符串,其他一切都是语言,操作系统所需要做的事,我们只需要处理好字符串的完整性。

## HTTP协议
超文本传输​​协议（HTTP，超文本传输​​协议）是互联网上应用最为广泛的一种网络协议。
所有的WWW文件都必须遵守这个标准。

设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。

1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext），这成为了HTTP超文本传输​​协议标准架构的发展根基.Ted Nelson组织协调万维网协会（ World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force）共同合作研究，最终发布了一系列的RFC，其中着名的RFC 2616定义了HTTP 1.1。


### 技术架构
HTTP是一个客户端和服务器端请求和应答的标准（TCP）。

客户端是终端用户，服务器端是网站。

通过使用网页浏览器，网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫用户代理（用户代理）。

应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在

多管中间层，比如代理，网关，或者隧道（隧道）。尽管TCP / IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。

事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现.HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。

通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接.HTTP服务器则在那个端口监听客户端发送过来的请求。

一旦收到请求，服务器（向客户端）发回一个状态行，比如“HTTP / 1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件，错误消息，或者其它一些信息。


HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。

通过HTTP或者HTTPS协议请求的资源由统一资源标示符（统一资源标识符）（或者，更准确一些，URL）来标识。

![](/img/in-post/post-blog/http.jpg)


### 过程解析
HTTP一次请求的过程大概如下：

- 用户在浏览器输入网址
- dns服务器解析/或者本机hosts，路由器主机对比获得ip
- 浏览器访问默认端口80，则访问的tcp地址为ip：80
- TCP协议3次握手，建立连接
- 发送一个http请求请求头
- 服务器获得http请求请求头，表明该次访问为http访问，解析http请求头，获得请求类型，请求格式，以及请求数据（cookie，get，post data）
- 服务器发送响应响应数据，主动断开
- 浏览器接收响应响应数据，解析响应文本类型，解析数据，断开连接

>HTTPS协议中，在请求以及响应时多了一层TLS，SSL加密解密协议，默认端口从80变为了443

### phper中的HTTP
由于PHP大部分时候都是用于网络服务器，所以PHP开发者接触最多的协议也就是基于TCP / IP协议的HTTP了协议

在PHP初级程序员中，其实没有详细的了解过的HTTP协议，但是可以通过浏览器的f12->网络去查看HTTP协议具体的请求头，以及服务端发送的响应头

## WebSocket协议
WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。

### 产生背景
在没有WebSocket协议之前,在网页中,实现一个聊天室只能使用ajax 不断轮询,请求服务器是否有数据产生,而这样的实现方法会出现一系列的问题:

如果轮询时间间隔太短,会导致客户端和服务端在一个时间段内不断的进行http tcp的握手/挥手动作和http 请求头,响应头的传输,大量消耗服务器资源,如果用户量大的情况,会造成服务器的繁忙以至于宕机
客户端每次只能通过发送http 请求获得服务器是否有数据返回,且数据的及时性无法保证
正因为在这种情况下,所以WebSocket出现了,它只需要一次http握手,就可以保持一个长连接,使得服务器可以主动发送消息给客户端,大大减少了轮询机制的消耗

### 实现原理
在实现websocket连线过程中，需要通过浏览器发出websocket连线请求，然后服务器发出回应，这个过程通常称为“握手” 。在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处：

- Header: 互相沟通的Header是很小的-大概只有 2 Bytes
- Server Push: 服务器的推送，服务器不再被动的接收到浏览器的请求之后才返回数据，而是在有新数据时就主动推送给浏览器。

### 握手协议
websocket握手

![](/img/in-post/post-blog/websocket.png)


首先,浏览器发起一个http协议的websocket握手请求:
```
GET /websocket/HTTP/1.1

Host: localhost
Upgrade: websocket          #表示希望将http协议升级到Websocket协议。
Connection: Upgrade         #表示希望将http协议升级到Websocket协议。
Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==   #浏览器随机生成的base64 encode的值，用来询问服务器是否是支持WebSocket。
Origin: http://服务器地址
Sec-WebSocket-Version: 13
```
websocket服务器响应:
```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket                #告诉浏览器已经升级到websocket
Connection: Upgrade               #告诉浏览器已经升级到websocket
Sec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=   #将请求包
“Sec-WebSocket-Key”的值，与” 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 ″这个字符串进行拼接，然后对拼接后的字符串进行sha-1运算，再进行base64编码得到的。用来说明自己是WebSocket助理服务器。
这样就已经是握手成功了,浏览器和服务端已经建立了一个websocket通道,发送数据不再需要tcp握手,也不需要发送http请求头,服务端也可自动下发数据到浏览器
```

HTML5 Web Socket API
在HTML5中内置有一些API，用于响应应用程序发起的请求。基本API语句如下：
```
var ws = new WebSocket(url,name);//创建对象
ws.send(msg);//发送文本消息
ws.onmessage = (function(evt/*服务器发送数据的对象*/){})();//接收消息回调事件
ws.onerror = (function(evt/*错误对象*/){})();//错误处理
ws.close();//关闭连接
```

## udp(传输层)
UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。

UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。

UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP用来支持那些需要在计算机之间传输数据的网络应用。

包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。

UDP协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天UDP仍然不失为一项非常实用和可行的网络传输层协议。


与所熟知的TCP（传输控制协议）协议一样，UDP协议直接位于IP（网际协议）协议的顶层。根据OSI（开放系统互连）参考模型，UDP和TCP都属于传输层协议。UDP协议的主要作用是将网络数据流量压缩成数据包的形式。一个典型的数据包就是一个二进制数据的传输单位。每一个数据包的前8个字节用来包含报头信息，剩余字节则用来包含具体的传输数据。

### udp与tcp
udp和tcp都属于传输层的协议,都位于ip协议的顶层,他们不同之处有:

- udp是无连接协议,不需要进行tcp的握手

- udp每次发送最大长度是65535,而tcp在握手后可以源源不断的发送

- udp协议使用报头中的校验值来保证数据的安全。校验值首先在数据发送方通过特殊的算法计算得出，在传递到接收方之后，还需要再重新计算。如果某个数据报在传输过程中被第三方篡改或者由于线路噪音等原因受到损坏，发送和接收方的校验计算值将不会相符，由此UDP协议可以检测是否出错。这与TCP协议是不同的，后者要求必须具有校验值。

- udp报文没有可靠性保证、顺序保证和流量控制字段等，可靠性较差。但是正因为udp协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。

- 在网络质量令人十分不满意的环境下，UDP协议数据包丢失会比较严重。而tcp会进行确认验证,确保对方接收成功

- udp可实现对网关内的所有主机进行广播

### phper的udp
在php初级开发者中,是很少接触到udp协议的,常见的有DNS协议,
在我们输入一个域名时,会先请求到一个dns服务器,由dns服务器匹配出一个ip地址,然后通过ip地址去传输数据, 在这个步骤中,请求dns服务器使用的就是udp协议

## 端口
在网络技术中，端口（Port）包括逻辑端口和物理端口两种类型。物理端口指的是物理存在的端口，如ADSL Modem、集线器、交换机、路由器上用 于连接其他网络设备的接口，如RJ-45端口、SC端口等等。逻辑端口是指逻辑意义上用于区分服务的端口，如TCP/IP协议中的服务端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等。由于物理端口和逻辑端口数量较多，为了对端口进行区分，将每个端口进行了编号，这就是端口号。本文主要讲逻辑端口.

### 逻辑端口
端口有什么用呢？我们知道，一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区 分不同的服务的。

服务器一般都是通过知名端口号来识别的。例如，对于每个TCP/IP实现来说，FTP服务器的TCP端口号都是21，每个Telnet服务器的TCP端口号都是23，每个TFTP(简单文件传送协议)服务器的UDP端口号都是69。任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。这些知名端口号由Internet 号分配机构（InternetAssignedNumbersAuthority,IANA）来管理。 到1992年为止，知名端口号介于1～255之间。256～1023之间的端口号通常都是由Unix系统占用，以提供一些特定的Unix服务—也就是说，提供一些只有Unix系统才有的、而其他操作系统可能不提供的服务，IANA管理1～1023之间所有的端口号。

Internet扩展服务与Unix特定服务之间的一个差别就是Telnet和Rlogin。它们二者都允许通过计算机网络登录到其他主机上。Telnet是采用端口号为23的TCP/IP标准且几乎可以在所有操作系统上进行实现。Rlogin只是为Unix系统设计的（尽管许多非Unix系统也提供该服务），它的有名端口号为513。

客户端通常对它所使用的端口号并不关心，只需保证该端口号在本机上是唯一的就可以了。客户端口号又称作临时端口号（即存在时间很短暂）。这是因为它通常只是在用户运行该客户程序时才存在，而服务器则只要主机开着的，其服务就运行。

大多数TCP/IP实现给临时端口分配1024～5000之间的端口号。大于5000的端口号是为其他服务器预留的（Internet上并不常用的服务)。我们可以在后面看见许多这样的给临时端口分配端口号的例子。 Solaris2.2是一个很有名的例外。通常TCP和UDP的缺省临时端口号从32768开始。